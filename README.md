# MPT报告

## 一、前言

### 1.1、Merkle Patricia Tree（又称为Merkle Patricia Trie）是一种经过改良的、融合了默克尔树和前缀树两种树结构优点的数据结构，是以太坊中用来组织管理账户数据、生成交易集合哈希的重要数据结构。

![image](https://user-images.githubusercontent.com/108848022/181465821-3ad365e0-2bbc-4ec6-937f-8f0c3877d761.png)

### 1.2、MPT树有以下几个作用：

（1）存储任意长度的key-value键值对数据；

（2）提供了一种快速计算所维护数据集哈希标识的机制；

（3）提供了快速状态回滚的机制；

（4）提供了一种称为默克尔证明的证明方法，进行轻节点的扩展，实现简单支付验证；

### 1.3、前缀树：又称字典树，用于保存关联数组，其键（key）的内容通常为字符串。前缀树节点在树中的位置是由其键的内容所决定的，即前缀树的key值被编码在根节点到该节点的路径中。

![image](https://user-images.githubusercontent.com/108848022/181465675-a108921a-7c92-4532-b78e-f423ebe8ebc4.png)

![image](https://user-images.githubusercontent.com/108848022/181462854-59fe05c4-ea69-45d8-aa49-611db60f333e.png)

（1）优势：相比于哈希表，使用前缀树来进行查询拥有共同前缀key的数据时十分高效，例如在字典中查找前缀为pre的单词，对于哈希表来说，需要遍历整个表，时间效率为O(n)；然而对于前缀树来说，只需要在树中找到前缀为pre的节点，且遍历以这个节点为根节点的子树即可。但是对于最差的情况（前缀为空串），时间效率为O(n)，仍然需要遍历整棵树，此时效率与哈希表相同。相比于哈希表，在前缀树不会存在哈希冲突的问题。

（2）劣势：直接查找效率低下（前缀树的查找效率是O(m)，m为所查找节点的key长度，而哈希表的查找效率为O(1)。且一次查找会有m次IO开销，相比于直接查找，无论是速率、还是对磁盘的压力都比较大）、可能会造成空间浪费（当存在一个节点，其key值内容很长（如一串很长的字符串），当树中没有与他相同前缀的分支时，为了存储该节点，需要创建许多非叶子节点来构建根节点到该节点间的路径，造成了存储空间的浪费）

### 1.4、默克尔树：

Merkle树是由计算机科学家 Ralph Merkle 在很多年前提出的，并以他本人的名字来命名,由于在比特币网络中用到了这种数据结构来进行数据正确性的验证，在这里简要地介绍一下merkle树的特点及原理。在比特币网络中，merkle树被用来归纳一个区块中的所有交易，同时生成整个交易集合的数字指纹。此外，由于merkle树的存在，使得在比特币这种公链的场景下，扩展一种“轻节点”实现简单支付验证变成可能，关于轻节点的内容，将会下文详述。

（1）特点：默克尔树是一种树，大多数是二叉树，也可以多叉树，无论是几叉树，它都具有树结构的所有特点；默克尔树叶子节点的value是数据项的内容，或者是数据项的哈希值；非叶子节点的value根据其孩子节点的信息，然后按照Hash算法计算而得出的；

（2）原理：将相邻两个节点的哈希值合并成一个字符串，然后计算这个字符串的哈希，得到的就是这两个节点的父节点的哈希值。如果该层的树节点个数是单数，那么对于最后剩下的树节点，这种情况就直接对它进行哈希运算，其父节点的哈希就是其哈希值的哈希值（对于单数个叶子节点，有着不同的处理方法，也可以采用复制最后一个叶子节点凑齐偶数个叶子节点的方式）。循环重复上述计算过程，最后计算得到最后一个节点的哈希值，将该节点的哈希值作为整棵树的哈希。若两棵树的根哈希一致，则这两棵树的结构、节点的内容必然相同。

（3）默克尔树的构造如下图所示：

![image](https://user-images.githubusercontent.com/108848022/181463475-8fc8b847-d81a-4d64-b78b-30df264e9dc1.png)

## 二、结构设计：

### 2.1、节点分类：

MPT树中，树节点可以分为以下四类：

（1）空节点：用来表示空串

（2）分支节点：分支节点用来表示MPT树中所有拥有超过1个孩子节点以上的非叶子节点。分支节点的孩子列表中，最后一个元素是用来存储自身的内容。

（3）叶子节点：叶子节点与扩展节点的定义相似。

（4）扩展节点：其中关键的字段为：Key：用来存储属于该节点范围的key；Val：用来存储该节点的内容；

前缀树中出现资源浪费的情况如下图所示：

![image](https://user-images.githubusercontent.com/108848022/181464051-f21343b9-311d-47bc-ae47-75d3c9ec647d.png)

### 2.2、key值编码：

在以太坊中，MPT树的key值共有三种不同的编码方式，以满足不同场景的不同需求，在这里对每一种进行介绍。三种编码方式分别为：

（1）Raw编码（原生的字符）：Raw编码就是原生的key值，不做任何改变。这种编码方式的key，是MPT对外提供接口的默认编码方式。

（2）Hex编码（扩展的16进制编码）：为了减少分支节点孩子的个数，需要将key的编码进行转换，将原key的高低四位分拆成两个字节进行存储。这种转换后的key的编码方式，就是Hex编码。

（3）Hex-Prefix编码（16进制前缀编码）：在介绍叶子／扩展节点时，我们介绍了这两种节点定义是共享的，即便持久化到数据库中，存储的方式也是一致的。那么当节点加载到内存是，同样需要通过一种额外的机制来区分节点的类型。于是以太坊就提出了一种HP编码对存储在数据库中的叶子／扩展节点的key进行编码区分。在将这两类节点持久化到数据库之前，首先会对该节点的key做编码方式的转换，即从Hex编码转换成HP编码。

（4）转换关系：

![image](https://user-images.githubusercontent.com/108848022/181464382-3069d40a-2e6f-4713-bb99-14cfc29ac462.png)

![image](https://user-images.githubusercontent.com/108848022/181465769-c1e328ac-940a-43a4-a4b1-cfaab2540d8c.png)


### 2.3、安全的MPT：

以上介绍的MPT树，可以用来存储内容为任何长度的key-value数据项。倘若数据项的key长度没有限制时，当树中维护的数据量较大时，仍然会造成整棵树的深度变得越来越深，会造成以下影响：

（1）查询一个节点可能会需要许多次IO读取，效率低下；

（2）系统易遭受Dos攻击，攻击者可以通过在合约中存储特定的数据，“构造”一棵拥有一条很长路径的树，然后不断地调用SLOAD指令读取该树节点的内容，造成系统执行效率极度下降；

（3）所有的key其实是一种明文的形式进行存储；

为了解决以上问题，在以太坊中对MPT再进行了一次封装，对数据项的key进行了一次哈希计算，因此最终作为参数传入到MPT接口的数据项其实是(sha3(key), value)

## 三、核心操作：

### 3.1、Get操作：

内容一致的路径；

（1）若当前节点为叶子节点，存储的内容是数据项的内容，且搜索路径的内容与叶子节点的key一致，则表示找到该节点；反之则表示该节点在树中不存在。

（2）若当前节点为扩展节点，且存储的内容是哈希索引，则利用哈希索引从数据库中加载该节点，再将搜索路径作为参数，对新解析出来的节点递归地调用查找函数。

（3）若当前节点为扩展节点，存储的内容是另外一个节点的引用，且当前节点的key是搜索路径的前缀，则将搜索路径减去当前节点的key，将剩余的搜索路径作为参数，对其子节点递归地调用查找函数；若当前节点的key不是搜索路径的前缀，表示该节点在树中不存在。

（4）若当前节点为分支节点，若搜索路径为空，则返回分支节点的存储内容；反之利用搜索路径的第一个字节选择分支节点的孩子节点，将剩余的搜索路径作为参数递归地调用查找函数。

![image](https://user-images.githubusercontent.com/108848022/181464750-5bf270df-3bae-4cd8-921f-d511373604ec.png)

### 3.2、Insert操作：具体过程在此不再赘述，如下图所示

![image](https://user-images.githubusercontent.com/108848022/181466035-0e692015-6e36-4254-83d6-b55c8b1a97b0.png)

![image](https://user-images.githubusercontent.com/108848022/181464897-b58ff923-3b85-4248-a0a8-a7eacfd61c73.png)

### 3.3、Delete操作：

删除操作与插入操作类似，都需要借助查找过程完成，一次删除过程为：

1、根据3.1中描述的查找步骤，找到与需要插入的节点拥有最长相同路径前缀的节点，记为Node；

2、若Node为叶子／扩展节点：

（1）若剩余的搜索路径与node的Key完全一致，则将整个node删除；

（2）若剩余的搜索路径与node的key不匹配，则表示需要删除的节点不存于树中，删除失败；

（3）若node的key是剩余搜索路径的前缀，则对该节点的Val做递归的删除调用；

3、若Node为分支节点：

（1） 删除孩子列表中相应下标标志的节点；

（2） 删除结束，若Node的孩子个数只剩下一个，那么将分支节点替换成一个叶子／扩展节点；

4、若删除成功，则将被修改节点的dirty标志置为true，hash标志置空（之前的结果已经不可能用），且将节点的诞生标记更新为现在；

![image](https://user-images.githubusercontent.com/108848022/181465274-65953e93-ed6b-4016-a32b-abc51066b905.png)

## 四、其余备注：

### 4.1、默克尔证明：

默克尔证明指一个轻节点向一个全节点发起一次证明请求，询问全节点完整的默克尔树中，是否存在一个指定的节点；全节点向轻节点返回一个默克尔证明路径，由轻节点进行计算，验证存在性。

### 4.2、默克尔证明过程：

如有棵如下图所示的merkle树，如果某个轻节点想要验证9Dog:64这个树节点是否存在与默克尔树中，只需要向全节点发送该请求，全节点会返回一个1FXq:18, ec20,8f74的一个路径（默克尔路径，如图2黄色框所表示的）。得到路径之后，轻节点利用9Dog:64与1FXq:18求哈希，在与ec20求哈希，最后与8f74求哈希，得到的结果与本地维护的根哈希相比，是否相等。

![image](https://user-images.githubusercontent.com/108848022/181465567-5b58045c-ccf9-4ff9-8203-cece93daa4fd.png)

### 4.3、以太坊从 MPT 中查询查找某 Key 对应数据的流程图：

![image](https://user-images.githubusercontent.com/108848022/181465939-943e773f-5836-4987-9890-1f3c480019fd.png)

### 4.4、持久化：

（1）当需要将 MPT Commit 到 DB 时，这颗树的数据是如何完整存储到数据库的呢？以太坊的持久层是 KV 数据库，一个 Key 对应一份存储内容。 当上面在计算 Root 值时，实际上已完成了哈希值和节点内容的处理过程。不同于在内存中计算 Root 值，在持久化时是持久化和 Hash 计算同步进行。

（2）从Root的计算规则可知，HASH 计算是递归的，从树的叶子节点向上计算。每次计算出一个节点哈希时，将使用此哈希值作为数据库的 Key，存放节点的 RLP 持久化内容到数据库中。 因为节点哈希值以及被包含在父节点中，直至树根。因此，我们只需要知道一颗树的 Root 值，便可以依次从 DB 中读取节点数据，并在内存中构建完整的 MPT 树。


